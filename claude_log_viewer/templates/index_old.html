<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Log Viewer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.0.0/dist/markdown-it.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding-bottom: 60px;
        }

        .header {
            background: #2d2d30;
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 12px;
            color: #9d9d9d;
        }

        input[type="text"], select {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 6px 10px;
            border-radius: 3px;
            font-size: 12px;
            font-family: inherit;
        }

        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #007acc;
        }

        button {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 6px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
        }

        button:hover {
            background: #1177bb;
        }

        button:active {
            background: #0d5a8f;
        }

        .field-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            padding: 10px 0;
        }

        .field-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            background: #3c3c3c;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
        }

        .field-checkbox:hover {
            background: #4e4e4e;
        }

        .field-checkbox input[type="checkbox"] {
            cursor: pointer;
        }

        .field-checkbox label {
            cursor: pointer;
            font-size: 11px;
            color: #9d9d9d;
        }

        .stats {
            font-size: 11px;
            color: #9d9d9d;
            padding: 5px 0;
        }

        .chat-summary {
            background: #252526;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }

        .chat-summary h3 {
            font-size: 12px;
            color: #9d9d9d;
            text-transform: uppercase;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .session-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 10px;
        }

        .session-card {
            background: #2d2d30;
            padding: 12px;
            border-radius: 4px;
            border-left: 4px solid;
            transition: background 0.2s;
            position: relative;
        }

        .session-card:hover {
            background: #3e3e42;
        }

        .session-card.selected {
            background: #3e3e42;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        /* Icon action bar */
        .session-icon-actions {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            padding: 0 16px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            border-radius: 4px;
        }

        .session-card:hover .session-icon-actions {
            opacity: 1;
            pointer-events: all;
        }

        .session-icon-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 120px;
        }

        .session-icon-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .session-icon-btn[data-action="filter"].active {
            background: rgba(14, 99, 156, 0.8);
            border: 1px solid rgba(14, 99, 156, 1);
        }

        .session-icon-btn .icon {
            font-size: 24px;
            line-height: 1;
        }

        .session-icon-btn .label {
            font-size: 11px;
            color: #d4d4d4;
            white-space: nowrap;
            font-weight: 500;
        }

        .session-id {
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 8px;
            word-break: break-all;
        }

        .session-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
            color: #9d9d9d;
        }

        .session-stat {
            display: flex;
            justify-content: space-between;
        }

        .session-stat-label {
            color: #6e7681;
        }

        .session-stat-value {
            color: #d4d4d4;
            font-weight: 500;
        }

        .session-color-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
        }

        .usage-dashboard {
            background: #2d2d30;
            padding: 10px 20px;
            border-top: 1px solid #3e3e42;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .usage-dashboard h3 {
            display: none;
        }

        .usage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            max-width: 600px;
        }

        .usage-item {
            background: #252526;
            padding: 8px 12px;
            border-radius: 3px;
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }

        .usage-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .usage-label {
            font-size: 9px;
            color: #6e7681;
            text-transform: uppercase;
        }

        .usage-time {
            font-size: 9px;
            color: #9d9d9d;
        }

        .usage-value {
            font-size: 14px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 3px;
            text-align: center;
            min-width: 60px;
        }

        .usage-value.low {
            background: rgba(26, 127, 55, 0.2);
            color: #4fc1ff;
        }

        .usage-value.medium {
            background: rgba(191, 135, 0, 0.2);
            color: #f9c513;
        }

        .usage-value.high {
            background: rgba(207, 34, 46, 0.2);
            color: #f97583;
        }

        .usage-error {
            color: #f97583;
            font-size: 11px;
            padding: 10px;
            background: rgba(207, 34, 46, 0.1);
            border-radius: 3px;
        }

        .content {
            flex: 1;
            overflow: auto;
            padding: 0;
        }

        .table-container {
            width: 100%;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: #252526;
        }

        thead {
            position: sticky;
            top: 0;
            background: #2d2d30;
            z-index: 10;
        }

        th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: 11px;
            color: #9d9d9d;
            text-transform: uppercase;
            border-bottom: 2px solid #3e3e42;
            white-space: nowrap;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #3e3e42;
            vertical-align: top;
            max-width: 400px;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            position: relative;
        }

        td:hover {
            background: #2d2d30;
        }

        td:active {
            background: #3e3e42;
        }

        tr:hover {
            background: #2d2d30;
        }

        .copy-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #0e639c;
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-10px); }
            10% { opacity: 1; transform: translateY(0); }
            90% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        .cell-type {
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            display: inline-block;
        }

        .type-user { background: #1a7f37; color: #fff; }
        .type-assistant { background: #0969da; color: #fff; }
        .type-tool_result { background: #bf8700; color: #fff; }
        .type-file-history-snapshot { background: #8250df; color: #fff; }
        .type-other { background: #6e7681; color: #fff; }

        .role-user { background: #1a7f37; color: #fff; }
        .role-assistant { background: #0969da; color: #fff; }

        .cell-json {
            background: #1e1e1e;
            padding: 6px;
            border-radius: 3px;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .cell-text {
            color: #d4d4d4;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .cell-text.truncated {
            cursor: pointer;
        }

        .cell-text.truncated:hover {
            background: #2d2d30;
        }

        .cell-text.has-tools {
            cursor: pointer;
        }

        .cell-text.has-tools:hover {
            background: #2d2d30;
        }

        .expand-indicator {
            color: #007acc;
            font-size: 10px;
            margin-left: 5px;
        }

        .cell-timestamp {
            color: #9d9d9d;
            font-size: 11px;
            white-space: nowrap;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6e7681;
        }

        .empty-state h2 {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6e7681;
        }

        .auto-refresh {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .auto-refresh.active {
            color: #4fc1ff;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Modal dialog styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-dialog {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            border-radius: 6px;
            max-width: 900px;
            max-height: 90vh;
            width: 100%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }

        .modal-close {
            background: transparent;
            border: none;
            color: #9d9d9d;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .modal-close:hover {
            background: #3e3e42;
            color: #fff;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-content {
            color: #d4d4d4;
            line-height: 1.6;
        }

        /* Plan navigation controls */
        .plan-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            margin-bottom: 20px;
        }

        .plan-nav-btn {
            background: #0e639c;
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .plan-nav-btn:hover:not(:disabled) {
            background: #1177bb;
        }

        .plan-nav-btn:disabled {
            background: #3c3c3c;
            color: #666;
            cursor: not-allowed;
        }

        .plan-counter {
            font-size: 13px;
            color: #9d9d9d;
            font-weight: 500;
        }

        /* Markdown content styles */
        .modal-content h1 {
            font-size: 24px;
            margin: 20px 0 10px 0;
            color: #fff;
            border-bottom: 1px solid #3e3e42;
            padding-bottom: 8px;
        }

        .modal-content h2 {
            font-size: 20px;
            margin: 18px 0 8px 0;
            color: #fff;
        }

        .modal-content h3 {
            font-size: 16px;
            margin: 16px 0 8px 0;
            color: #fff;
        }

        .modal-content p {
            margin: 10px 0;
        }

        .modal-content code {
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 12px;
            color: #f97583;
        }

        .modal-content pre {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 10px 0;
            border: 1px solid #3e3e42;
        }

        .modal-content pre code {
            background: transparent;
            padding: 0;
            color: #d4d4d4;
        }

        .modal-content ul, .modal-content ol {
            margin: 10px 0;
            padding-left: 30px;
        }

        .modal-content li {
            margin: 5px 0;
        }

        .modal-content blockquote {
            border-left: 4px solid #007acc;
            padding-left: 15px;
            margin: 10px 0;
            color: #9d9d9d;
            font-style: italic;
        }

        .modal-content a {
            color: #4fc1ff;
            text-decoration: none;
        }

        .modal-content a:hover {
            text-decoration: underline;
        }

        .modal-content table {
            border-collapse: collapse;
            margin: 10px 0;
            width: 100%;
        }

        .modal-content table th,
        .modal-content table td {
            border: 1px solid #3e3e42;
            padding: 8px;
            text-align: left;
        }

        .modal-content table th {
            background: #1e1e1e;
            font-weight: 600;
        }

        .modal-content hr {
            border: none;
            border-top: 1px solid #3e3e42;
            margin: 20px 0;
        }

        .cell-text.truncated {
            cursor: pointer;
            transition: background 0.2s;
        }

        .cell-text.truncated:hover {
            background: #3e3e42 !important;
        }

        /* Usage increment row styles */
        .usage-increment-row {
            background: linear-gradient(90deg, #1e1e1e 0%, #2a2a3a 50%, #1e1e1e 100%);
        }

        .usage-increment-row:hover {
            background: linear-gradient(90deg, #252525 0%, #32324a 50%, #252525 100%);
        }

        .usage-increment-cell {
            padding: 0 !important;
            border-top: 2px solid #007acc;
            border-bottom: 2px solid #007acc;
        }

        .usage-increment-container {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            gap: 20px;
        }

        .usage-increment-icon {
            font-size: 32px;
            line-height: 1;
            flex-shrink: 0;
        }

        .usage-increment-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .usage-increment-title {
            font-size: 14px;
            font-weight: 600;
            color: #4fc1ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .usage-increment-details {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .usage-increment-stat {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .usage-increment-label {
            font-size: 12px;
            color: #9d9d9d;
            font-weight: 500;
        }

        .usage-increment-value {
            font-size: 13px;
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 3px;
        }

        .usage-increment-meta {
            font-size: 11px;
            color: #8d8d8d;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .usage-increment-time {
            font-size: 11px;
            color: #7d7d7d;
            white-space: nowrap;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Claude Code Log Viewer</h1>

        <div class="controls">
            <div class="control-group">
                <label>Search:</label>
                <input type="text" id="searchInput" placeholder="Filter entries..." style="width: 250px;">
            </div>

            <div class="control-group">
                <label>Type:</label>
                <select id="typeFilter">
                    <option value="">All Types</option>
                    <option value="user">User</option>
                    <option value="assistant">Assistant</option>
                    <option value="tool_result">Tool Result</option>
                    <option value="file-history-snapshot">File History</option>
                </select>
            </div>

            <div class="control-group">
                <label>Limit:</label>
                <select id="limitSelect">
                    <option value="50">50</option>
                    <option value="100" {% if max_entries == 100 %}selected{% endif %}>100</option>
                    <option value="200" {% if max_entries == 200 %}selected{% endif %}>200</option>
                    <option value="500" {% if max_entries == 500 %}selected{% endif %}>500</option>
                    {% if max_entries not in [50, 100, 200, 500] %}
                    <option value="{{ max_entries }}" selected>{{ max_entries }}</option>
                    {% endif %}
                </select>
            </div>

            <button id="refreshBtn">Refresh</button>

            <div class="control-group auto-refresh" id="autoRefresh">
                <input type="checkbox" id="autoRefreshCheck">
                <label for="autoRefreshCheck">Auto-refresh</label>
            </div>

            <div class="control-group">
                <label>Interval (s):</label>
                <select id="refreshInterval">
                    <option value="1" selected>1s</option>
                    <option value="2">2s</option>
                    <option value="5">5s</option>
                    <option value="10">10s</option>
                    <option value="30">30s</option>
                    <option value="60">60s</option>
                </select>
            </div>
        </div>

        <div class="field-selector" id="fieldSelector">
            <!-- Populated by JS -->
        </div>

        <div class="stats" id="stats">Loading...</div>

        <div class="chat-summary" id="chatSummary">
            <h3>Active Sessions</h3>
            <div class="session-cards" id="sessionCards">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <div class="content">
        <div id="entriesContainer">
            <div class="loading">Loading entries...</div>
        </div>
    </div>

    <div class="usage-dashboard" id="usageDashboard">
        <div class="usage-grid" id="usageGrid">
            <!-- Populated by JS -->
        </div>
    </div>

    <script>
        let allEntries = [];
        let selectedFields = new Set(['role', 'when', 'content', 'sessionId', 'content_tokens']);
        let autoRefreshInterval = null;
        let knownFields = new Set(); // Track known fields to avoid re-rendering
        let sessionColors = {}; // Map sessionId to color
        let selectedSession = null; // Currently selected session filter
        let currentPlanNavigation = null; // Track current plan navigation state: { session, currentIndex }
        let currentTodoNavigation = null; // Track current todo navigation state: { session, currentIndex }
        let renderedEntryIds = new Set(); // Track which entries are already in the DOM
        let allTodoData = {}; // Store all todo data from API, keyed by sessionId
        let currentFilters = { // Track current filter state
            search: '',
            type: '',
            session: null,
            limit: {{ max_entries }},
            fields: new Set(['role', 'when', 'content', 'sessionId'])
        };
        let lastSessionStats = {}; // Track previous session stats for incremental updates
        let usageRefreshInterval = null; // Interval for usage polling

        // Plan limits (hours per week)
        const planLimits = {
            pro: { sonnet: 80, opus: 0 },
            max5x: { sonnet: 280, opus: 35 },
            max20x: { sonnet: 480, opus: 40 }
        };

        // Color palette for sessions
        const colorPalette = [
            '#1a7f37', '#0969da', '#bf8700', '#8250df', '#cf222e',
            '#1f6feb', '#d29922', '#8957e5', '#ea4a5a', '#0969da',
            '#2da44e', '#1f883d', '#bc4c00', '#6639ba', '#d1242f'
        ];

        // Initialize markdown-it with syntax highlighting
        const md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            highlight: function (str, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(str, { language: lang }).value;
                    } catch (__) {}
                }
                return '';
            }
        });

        // Show content in modal dialog
        function showContentDialog(content) {
            const modal = document.getElementById('contentModal');
            const modalContent = document.getElementById('modalContent');

            // Parse and render markdown
            const htmlContent = md.render(content);
            modalContent.innerHTML = htmlContent;

            // Show modal
            modal.classList.add('active');
        }

        // Show tool details dialog with JSON
        function showToolDetailsDialog(entry) {
            const modal = document.getElementById('contentModal');
            const modalContent = document.getElementById('modalContent');

            // Build markdown content with tool details
            let markdownContent = '# Tool Use & Result Details\n\n';

            // Add entry context
            markdownContent += `**Session:** ${entry.sessionId || 'N/A'}  \n`;
            markdownContent += `**Timestamp:** ${entry.timestamp || 'N/A'}  \n`;
            markdownContent += `**Type:** ${entry.type || 'N/A'}\n\n`;

            // Add summary from content_display
            if (entry.content_display) {
                markdownContent += '## Summary\n\n';
                markdownContent += entry.content_display + '\n\n';
            }

            // Add tool uses
            if (entry.tool_items?.tool_uses?.length > 0) {
                markdownContent += '## Tool Uses\n\n';
                entry.tool_items.tool_uses.forEach((toolUse, index) => {
                    markdownContent += `### ${index + 1}. ${toolUse.name}\n\n`;
                    markdownContent += '```json\n';
                    markdownContent += JSON.stringify(toolUse, null, 2);
                    markdownContent += '\n```\n\n';
                });
            }

            // Add tool results
            if (entry.tool_items?.tool_results?.length > 0) {
                markdownContent += '## Tool Results\n\n';
                entry.tool_items.tool_results.forEach((toolResult, index) => {
                    markdownContent += `### Result ${index + 1}\n\n`;
                    if (toolResult.is_error) {
                        markdownContent += '⚠️ **Error Result**\n\n';
                    }
                    markdownContent += '```json\n';
                    markdownContent += JSON.stringify(toolResult, null, 2);
                    markdownContent += '\n```\n\n';
                });
            }

            // Add toolUseResult metadata if present
            if (entry.tool_items?.toolUseResult) {
                markdownContent += '## Tool Metadata\n\n';
                markdownContent += '```json\n';
                markdownContent += JSON.stringify(entry.tool_items.toolUseResult, null, 2);
                markdownContent += '\n```\n\n';
            }

            // Parse and render markdown
            const htmlContent = md.render(markdownContent);
            modalContent.innerHTML = htmlContent;

            // Show modal
            modal.classList.add('active');
        }

        // Show plan dialog with navigation
        function showPlanDialog(session, planIndex = 0) {
            const modal = document.getElementById('contentModal');
            const modalContent = document.getElementById('modalContent');

            if (!session.planEntries || session.planEntries.length === 0) {
                return;
            }

            // Sort plans by timestamp (newest first)
            const sortedPlans = [...session.planEntries].sort((a, b) =>
                b.timestamp.localeCompare(a.timestamp)
            );

            // Ensure planIndex is valid
            planIndex = Math.max(0, Math.min(planIndex, sortedPlans.length - 1));

            // Store current navigation state
            currentPlanNavigation = {
                session: session,
                currentIndex: planIndex
            };

            const currentPlan = sortedPlans[planIndex];

            // Build markdown content with navigation info
            let markdownContent = `# Plan ${planIndex + 1} of ${sortedPlans.length} - Session ${session.id.substring(0, 8)}\n\n`;
            markdownContent += `**Timestamp:** ${currentPlan.timestamp}\n\n`;
            markdownContent += '---\n\n';
            markdownContent += currentPlan.plan;

            // Parse and render markdown
            const htmlContent = md.render(markdownContent);

            // Build navigation controls
            const hasPrev = planIndex < sortedPlans.length - 1;
            const hasNext = planIndex > 0;

            const navControls = `
                <div class="plan-navigation">
                    <button class="plan-nav-btn" id="planPrevBtn" ${!hasPrev ? 'disabled' : ''}>
                        ← Older
                    </button>
                    <span class="plan-counter">${planIndex + 1} / ${sortedPlans.length}</span>
                    <button class="plan-nav-btn" id="planNextBtn" ${!hasNext ? 'disabled' : ''}>
                        Newer →
                    </button>
                </div>
            `;

            modalContent.innerHTML = navControls + htmlContent;

            // Add event listeners for navigation buttons
            const prevBtn = document.getElementById('planPrevBtn');
            const nextBtn = document.getElementById('planNextBtn');

            if (prevBtn && hasPrev) {
                prevBtn.addEventListener('click', () => {
                    showPlanDialog(session, planIndex + 1);
                });
            }

            if (nextBtn && hasNext) {
                nextBtn.addEventListener('click', () => {
                    showPlanDialog(session, planIndex - 1);
                });
            }

            // Show modal
            modal.classList.add('active');
        }

        // Navigate plan (used for keyboard navigation)
        function navigatePlan(direction) {
            if (!currentPlanNavigation) return;

            const { session, currentIndex } = currentPlanNavigation;
            const sortedPlans = [...session.planEntries].sort((a, b) =>
                b.timestamp.localeCompare(a.timestamp)
            );

            let newIndex = currentIndex;
            if (direction === 'prev' && currentIndex < sortedPlans.length - 1) {
                newIndex = currentIndex + 1;
            } else if (direction === 'next' && currentIndex > 0) {
                newIndex = currentIndex - 1;
            }

            if (newIndex !== currentIndex) {
                showPlanDialog(session, newIndex);
            }
        }

        // Navigate todo (used for keyboard navigation)
        function navigateTodo(direction) {
            if (!currentTodoNavigation) return;

            const { session, currentIndex } = currentTodoNavigation;
            const sortedTodos = [...session.todoEntries].sort((a, b) =>
                b.timestamp.localeCompare(a.timestamp)
            );

            let newIndex = currentIndex;
            if (direction === 'prev' && currentIndex < sortedTodos.length - 1) {
                newIndex = currentIndex + 1;
            } else if (direction === 'next' && currentIndex > 0) {
                newIndex = currentIndex - 1;
            }

            if (newIndex !== currentIndex) {
                showTodoDialog(session, newIndex);
            }
        }

        // Show todo list dialog with navigation
        function showTodoDialog(session, todoIndex = 0) {
            const modal = document.getElementById('contentModal');
            const modalContent = document.getElementById('modalContent');

            if (!session.todoEntries || session.todoEntries.length === 0) {
                return;
            }

            // Sort todos by timestamp (newest first)
            const sortedTodos = [...session.todoEntries].sort((a, b) =>
                b.timestamp.localeCompare(a.timestamp)
            );

            // Ensure todoIndex is valid
            todoIndex = Math.max(0, Math.min(todoIndex, sortedTodos.length - 1));

            // Store current navigation state
            currentTodoNavigation = {
                session: session,
                currentIndex: todoIndex
            };

            const currentTodoEntry = sortedTodos[todoIndex];
            const todos = currentTodoEntry.todos;

            // Group todos by status
            const inProgress = todos.filter(t => t.status === 'in_progress');
            const pending = todos.filter(t => t.status === 'pending');
            const completed = todos.filter(t => t.status === 'completed');

            // Build markdown content with navigation info
            let markdownContent = `# Todo List ${todoIndex + 1} of ${sortedTodos.length} - Session ${session.id.substring(0, 8)}\n\n`;
            markdownContent += `**Agent:** ${currentTodoEntry.agentId.substring(0, 8)}\n\n`;
            markdownContent += `**Timestamp:** ${currentTodoEntry.timestamp}\n\n`;
            markdownContent += '---\n\n';

            // In Progress section
            if (inProgress.length > 0) {
                markdownContent += `## ⏳ In Progress (${inProgress.length})\n\n`;
                inProgress.forEach(todo => {
                    markdownContent += `- [ ] **${todo.content}**\n`;
                    if (todo.activeForm && todo.activeForm !== todo.content) {
                        markdownContent += `  - *${todo.activeForm}*\n`;
                    }
                });
                markdownContent += '\n';
            }

            // Pending section
            if (pending.length > 0) {
                markdownContent += `## ☐ Pending (${pending.length})\n\n`;
                pending.forEach(todo => {
                    markdownContent += `- [ ] ${todo.content}\n`;
                    if (todo.activeForm && todo.activeForm !== todo.content) {
                        markdownContent += `  - *${todo.activeForm}*\n`;
                    }
                });
                markdownContent += '\n';
            }

            // Completed section
            if (completed.length > 0) {
                markdownContent += `## ✅ Completed (${completed.length})\n\n`;
                completed.forEach(todo => {
                    markdownContent += `- [x] ${todo.content}\n`;
                    if (todo.activeForm && todo.activeForm !== todo.content) {
                        markdownContent += `  - *${todo.activeForm}*\n`;
                    }
                });
            }

            // Parse and render markdown
            const htmlContent = md.render(markdownContent);

            // Build navigation controls
            const hasPrev = todoIndex < sortedTodos.length - 1;
            const hasNext = todoIndex > 0;

            const navControls = `
                <div class="plan-navigation">
                    <button class="plan-nav-btn" id="todoPrevBtn" ${!hasPrev ? 'disabled' : ''}>
                        ← Older
                    </button>
                    <span class="plan-counter">${todoIndex + 1} / ${sortedTodos.length}</span>
                    <button class="plan-nav-btn" id="todoNextBtn" ${!hasNext ? 'disabled' : ''}>
                        Newer →
                    </button>
                </div>
            `;

            modalContent.innerHTML = navControls + htmlContent;

            // Add event listeners for navigation buttons
            const prevBtn = document.getElementById('todoPrevBtn');
            const nextBtn = document.getElementById('todoNextBtn');

            if (prevBtn && hasPrev) {
                prevBtn.addEventListener('click', () => {
                    showTodoDialog(session, todoIndex + 1);
                });
            }

            if (nextBtn && hasNext) {
                nextBtn.addEventListener('click', () => {
                    showTodoDialog(session, todoIndex - 1);
                });
            }

            // Show modal
            modal.classList.add('active');
        }

        // Close modal dialog
        function closeContentDialog() {
            const modal = document.getElementById('contentModal');
            modal.classList.remove('active');
            // Reset navigation states
            currentPlanNavigation = null;
            currentTodoNavigation = null;
        }

        // Set up modal event listeners after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const modalCloseBtn = document.getElementById('modalClose');
            const contentModal = document.getElementById('contentModal');

            if (modalCloseBtn) {
                modalCloseBtn.addEventListener('click', closeContentDialog);
            }

            if (contentModal) {
                contentModal.addEventListener('click', (e) => {
                    // Close when clicking on overlay (not on dialog itself)
                    if (e.target === e.currentTarget) {
                        closeContentDialog();
                    }
                });
            }

            // Close on Escape key and navigate plans/todos with arrow keys
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeContentDialog();
                } else if (e.key === 'ArrowLeft') {
                    // Navigate to older plan or todo
                    if (currentPlanNavigation) {
                        navigatePlan('prev');
                    } else if (currentTodoNavigation) {
                        navigateTodo('prev');
                    }
                } else if (e.key === 'ArrowRight') {
                    // Navigate to newer plan or todo
                    if (currentPlanNavigation) {
                        navigatePlan('next');
                    } else if (currentTodoNavigation) {
                        navigateTodo('next');
                    }
                }
            });
        });

        // Generate consistent color for session ID
        function getSessionColor(sessionId) {
            if (!sessionId) return '#6e7681';

            if (!sessionColors[sessionId]) {
                // Generate unique color using hash of session ID
                let hash = 0;
                for (let i = 0; i < sessionId.length; i++) {
                    hash = ((hash << 5) - hash) + sessionId.charCodeAt(i);
                    hash = hash & hash; // Convert to 32bit integer
                }

                // Use hash to generate HSL color
                const hue = Math.abs(hash) % 360;
                const saturation = 70; // Keep consistent saturation
                const lightness = 50;  // Keep consistent lightness

                sessionColors[sessionId] = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            }

            return sessionColors[sessionId];
        }

        // Generate unique ID for an entry
        function getEntryId(entry) {
            return entry.uuid || `${entry.sessionId || 'unknown'}-${entry.timestamp || Date.now()}`;
        }

        // Unpack message structure into flat fields
        function unpackEntry(entry) {
            const unpacked = { ...entry };

            if (entry.message) {
                // Extract role
                if (entry.message.role) {
                    unpacked.role = entry.message.role;
                }

                // Extract content - handle both string and array formats
                if (entry.message.content) {
                    const content = entry.message.content;
                    if (typeof content === 'string') {
                        unpacked.content = content;
                    } else if (Array.isArray(content)) {
                        // For arrays, extract text from first text block
                        const textBlock = content.find(c => c.type === 'text');
                        if (textBlock) {
                            unpacked.content = textBlock.text;
                        }
                        // Store full content as well
                        unpacked.content_full = content;
                    }
                }

                // Extract other useful message fields
                if (entry.message.model) {
                    unpacked.model = entry.message.model;
                }
                if (entry.message.stop_reason !== undefined) {
                    unpacked.stop_reason = entry.message.stop_reason;
                }

                // Extract token usage from API
                if (entry.message.usage) {
                    unpacked.input_tokens = entry.message.usage.input_tokens || 0;
                    unpacked.output_tokens = entry.message.usage.output_tokens || 0;
                }
            }

            // Extract counted tokens from actual content
            if (entry.content_tokens !== undefined) {
                unpacked.content_tokens = entry.content_tokens;
            }

            return unpacked;
        }

        // Truncate long text to first and last sentence
        function truncateContent(text, maxLength = 200) {
            if (!text || text.length <= maxLength) {
                return text;
            }

            // Split into sentences (simple split on . ! ?)
            const sentences = text.match(/[^\.!\?]+[\.!\?]+/g) || [text];

            if (sentences.length <= 2) {
                return text;
            }

            const firstSentence = sentences[0].trim();
            const lastSentence = sentences[sentences.length - 1].trim();

            return `${firstSentence} [...] ${lastSentence}`;
        }

        // Format timestamp as relative time ("5 minutes ago", "2 hours ago", etc.)
        function formatRelativeTime(timestamp) {
            if (!timestamp) return '-';

            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffSeconds = Math.floor(diffMs / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                if (diffSeconds < 60) {
                    return 'just now';
                } else if (diffMinutes < 60) {
                    return `${diffMinutes}m ago`;
                } else if (diffHours < 24) {
                    return `${diffHours}h ago`;
                } else if (diffDays < 7) {
                    return `${diffDays}d ago`;
                } else {
                    return date.toLocaleDateString();
                }
            } catch (e) {
                return '-';
            }
        }

        // Copy text to clipboard and show notification
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showCopyNotification();
            }).catch(err => {
                console.error('Failed to copy:', err);
            });
        }

        function showCopyNotification() {
            const notification = document.createElement('div');
            notification.className = 'copy-notification';
            notification.textContent = '✓ Copied to clipboard';
            document.body.appendChild(notification);

            setTimeout(() => {
                document.body.removeChild(notification);
            }, 2000);
        }

        // Format time remaining
        function formatTimeRemaining(resetTime) {
            const now = new Date();
            const reset = new Date(resetTime);
            const diff = reset - now;

            if (diff <= 0) return 'Resetting...';

            const hours = Math.floor(diff / 3600000);
            const mins = Math.floor((diff % 3600000) / 60000);

            if (hours > 24) {
                const days = Math.floor(hours / 24);
                const remainingHours = hours % 24;
                return `${days}d ${remainingHours}h`;
            } else if (hours > 0) {
                return `${hours}h ${mins}m`;
            } else {
                return `${mins}m`;
            }
        }

        // Get usage class based on percentage
        function getUsageClass(utilization) {
            if (utilization < 70) return 'low';
            if (utilization < 90) return 'medium';
            return 'high';
        }

        // Fetch and render usage data
        async function loadUsageData() {
            try {
                const response = await fetch('/api/usage');
                const data = await response.json();

                if (data.error) {
                    renderUsageError(data.error);
                    return;
                }

                renderUsageData(data);
            } catch (error) {
                console.error('Error loading usage data:', error);
                renderUsageError(error.message);
            }
        }

        function renderUsageError(errorMsg) {
            const container = document.getElementById('usageGrid');
            container.innerHTML = `<div class="usage-error">Failed to load usage data: ${errorMsg}</div>`;
        }

        function renderUsageData(data) {
            const container = document.getElementById('usageGrid');
            container.innerHTML = '';

            // 5-hour window
            if (data.five_hour) {
                const item = document.createElement('div');
                item.className = 'usage-item clickable';
                item.style.cursor = 'pointer';

                const utilization = data.five_hour.utilization || 0;
                const usageClass = getUsageClass(utilization);

                item.innerHTML = `
                    <div class="usage-info">
                        <div class="usage-label">5-Hour Window</div>
                        <div class="usage-time">Resets in ${formatTimeRemaining(data.five_hour.resets_at)}</div>
                    </div>
                    <div class="usage-value ${usageClass}">${utilization.toFixed(1)}%</div>
                `;

                item.addEventListener('click', () => showUsageHistory());

                container.appendChild(item);
            }

            // 7-day window
            if (data.seven_day) {
                const item = document.createElement('div');
                item.className = 'usage-item clickable';
                item.style.cursor = 'pointer';

                const utilization = data.seven_day.utilization || 0;
                const usageClass = getUsageClass(utilization);

                item.innerHTML = `
                    <div class="usage-info">
                        <div class="usage-label">7-Day Window</div>
                        <div class="usage-time">Resets in ${formatTimeRemaining(data.seven_day.resets_at)}</div>
                    </div>
                    <div class="usage-value ${usageClass}">${utilization.toFixed(1)}%</div>
                `;

                item.addEventListener('click', () => showUsageHistory());

                container.appendChild(item);
            }
        }

        // Show usage history modal with all snapshots
        async function showUsageHistory() {
            const modal = document.getElementById('contentModal');
            const modalContent = document.getElementById('modalContent');

            try {
                // Fetch all snapshots
                const now = new Date().toISOString();
                const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();

                const response = await fetch(`/api/usage-snapshots?start=${oneWeekAgo}&end=${now}`);
                const data = await response.json();

                if (data.error) {
                    modalContent.innerHTML = `<div style="color: #f48771;">Error loading snapshots: ${data.error}</div>`;
                    modal.classList.add('active');
                    return;
                }

                const snapshots = data.snapshots || [];

                if (snapshots.length === 0) {
                    modalContent.innerHTML = `
                        <h2>Usage History</h2>
                        <p style="color: #9d9d9d; margin-top: 20px;">No usage snapshots recorded yet.</p>
                        <p style="color: #9d9d9d; margin-top: 10px;">Snapshots are automatically created whenever your 5-hour or 7-day usage increases.</p>
                    `;
                } else {
                    // Build table
                    let tableHTML = `
                        <h2>Usage History (${snapshots.length} snapshots)</h2>
                        <div style="overflow-x: auto; margin-top: 20px;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 2px solid #3e3e42;">
                                        <th style="padding: 10px; text-align: left; color: #9d9d9d;">When</th>
                                        <th style="padding: 10px; text-align: left; color: #9d9d9d;">Timestamp</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">5h Util</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">5h Tokens</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">5h Messages</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">7d Util</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">7d Tokens</th>
                                        <th style="padding: 10px; text-align: right; color: #9d9d9d;">7d Messages</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;

                    snapshots.reverse().forEach(snapshot => {
                        const timestamp = new Date(snapshot.timestamp).toLocaleString();
                        const when = formatRelativeTime(snapshot.timestamp);
                        const fiveHourPct = (snapshot.five_hour_pct || 0).toFixed(1);
                        const sevenDayPct = (snapshot.seven_day_pct || 0).toFixed(1);
                        const fiveHourClass = getUsageClass(snapshot.five_hour_pct || 0);
                        const sevenDayClass = getUsageClass(snapshot.seven_day_pct || 0);

                        // Format token/message data with "total (+delta)" format
                        const formatValue = (val) => val !== null && val !== undefined ? formatNumber(val) : '—';
                        const formatWithDelta = (total, delta) => {
                            if (total === null || total === undefined) return '—';
                            if (delta === null || delta === undefined) return formatValue(total);
                            return `${formatValue(total)} (+${formatValue(delta)})`;
                        };

                        const fiveHourTokens = formatWithDelta(snapshot.five_hour_tokens_total, snapshot.five_hour_tokens_consumed);
                        const fiveHourMessages = formatWithDelta(snapshot.five_hour_messages_total, snapshot.five_hour_messages_count);
                        const sevenDayTokens = formatWithDelta(snapshot.seven_day_tokens_total, snapshot.seven_day_tokens_consumed);
                        const sevenDayMessages = formatWithDelta(snapshot.seven_day_messages_total, snapshot.seven_day_messages_count);

                        tableHTML += `
                            <tr style="border-bottom: 1px solid #2d2d30;">
                                <td style="padding: 10px; color: #9d9d9d; font-weight: 500;">${when}</td>
                                <td style="padding: 10px; color: #7d7d7d; font-size: 11px;">${timestamp}</td>
                                <td style="padding: 10px; text-align: right;">
                                    <span class="usage-value ${fiveHourClass}" style="padding: 2px 6px; font-size: 11px;">${fiveHourPct}%</span>
                                </td>
                                <td style="padding: 10px; text-align: right; color: #8d8d8d; font-size: 11px;">${fiveHourTokens}</td>
                                <td style="padding: 10px; text-align: right; color: #8d8d8d; font-size: 11px;">${fiveHourMessages}</td>
                                <td style="padding: 10px; text-align: right;">
                                    <span class="usage-value ${sevenDayClass}" style="padding: 2px 6px; font-size: 11px;">${sevenDayPct}%</span>
                                </td>
                                <td style="padding: 10px; text-align: right; color: #8d8d8d; font-size: 11px;">${sevenDayTokens}</td>
                                <td style="padding: 10px; text-align: right; color: #8d8d8d; font-size: 11px;">${sevenDayMessages}</td>
                            </tr>
                        `;
                    });

                    tableHTML += `
                                </tbody>
                            </table>
                        </div>
                    `;

                    modalContent.innerHTML = tableHTML;
                }

                modal.classList.add('active');
            } catch (error) {
                console.error('Error fetching usage history:', error);
                modalContent.innerHTML = `<div style="color: #f48771;">Failed to load usage history: ${error.message}</div>`;
                modal.classList.add('active');
            }
        }

        function startUsagePolling() {
            // Initial load
            loadUsageData();

            // Poll every 60 seconds
            usageRefreshInterval = setInterval(loadUsageData, 60000);
        }

        // Fetch usage snapshots and convert to entry format
        async function fetchUsageSnapshots() {
            try {
                // Get time range from all entries
                if (allEntries.length === 0) return [];

                const timestamps = allEntries
                    .map(e => e.timestamp)
                    .filter(t => t);

                if (timestamps.length === 0) return [];

                const startTime = timestamps[timestamps.length - 1]; // Oldest
                const endTime = timestamps[0]; // Newest

                const response = await fetch(`/api/usage-snapshots?start=${encodeURIComponent(startTime)}&end=${encodeURIComponent(endTime)}`);
                const data = await response.json();

                if (data.error) {
                    console.error('Error fetching usage snapshots:', data.error);
                    return [];
                }

                // Convert snapshots to entry format
                return data.snapshots.map(snapshot => ({
                    type: 'usage-increment',
                    timestamp: snapshot.timestamp,
                    sessionId: null, // Snapshots are global, not tied to a session
                    content: 'Usage Increment',
                    content_display: formatUsageSnapshot(snapshot),
                    snapshot: snapshot,
                    _isSnapshot: true
                }));
            } catch (error) {
                console.error('Error fetching usage snapshots:', error);
                return [];
            }
        }

        // Format usage snapshot for display
        function formatUsageSnapshot(snapshot) {
            const fiveHourPct = snapshot.five_hour_pct ? snapshot.five_hour_pct.toFixed(1) : '0.0';
            const sevenDayPct = snapshot.seven_day_pct ? snapshot.seven_day_pct.toFixed(1) : '0.0';

            return `📊 Usage Update: 5h: ${fiveHourPct}% utilization | 7d: ${sevenDayPct}% utilization`;
        }

        // Load initial data
        async function loadEntries() {
            try {
                // Fetch entries and todos in parallel
                const [entriesResponse, todosResponse] = await Promise.all([
                    fetch('/api/entries'),
                    fetch('/api/todos')
                ]);

                const data = await entriesResponse.json();
                const todosData = await todosResponse.json();

                // Store todo data globally, grouped by session
                allTodoData = {};
                if (todosData.todos) {
                    todosData.todos.forEach(todoFile => {
                        const sessionId = todoFile.sessionId;
                        if (!allTodoData[sessionId]) {
                            allTodoData[sessionId] = [];
                        }
                        allTodoData[sessionId].push(todoFile);
                    });
                }

                // Unpack all entries
                allEntries = data.entries.map(unpackEntry);

                // Fetch and merge usage snapshots
                const snapshots = await fetchUsageSnapshots();
                if (snapshots.length > 0) {
                    allEntries = [...allEntries, ...snapshots];
                    // Re-sort by timestamp (newest first)
                    allEntries.sort((a, b) => {
                        const timeA = a.timestamp || '';
                        const timeB = b.timestamp || '';
                        return timeB.localeCompare(timeA);
                    });
                }

                // Only update field selector if fields have changed
                const currentFields = new Set();
                allEntries.forEach(entry => {
                    Object.keys(entry).forEach(key => currentFields.add(key));
                });

                // Check if fields changed
                const fieldsChanged = currentFields.size !== knownFields.size ||
                    ![...currentFields].every(f => knownFields.has(f));

                if (fieldsChanged) {
                    knownFields = currentFields;
                    renderFieldSelector();
                }

                renderSessionSummary();
                updateStats();
                renderEntries();
            } catch (error) {
                console.error('Error loading entries:', error);
            }
        }

        // Load available fields
        async function loadFields() {
            try {
                const response = await fetch('/api/fields');
                const fields = await response.json();
                renderFieldSelector(fields);
            } catch (error) {
                console.error('Error loading fields:', error);
            }
        }

        function renderFieldSelector(fields) {
            const container = document.getElementById('fieldSelector');
            container.innerHTML = '';

            // Get all unique fields from unpacked entries
            const allFields = new Set();
            allEntries.forEach(entry => {
                Object.keys(entry).forEach(key => allFields.add(key));
            });

            // Add virtual computed fields
            allFields.add('when');
            allFields.add('tokens');

            const commonFields = ['role', 'when', 'timestamp', '_file', 'content', 'content_tokens', 'tokens', 'input_tokens', 'output_tokens', 'sessionId', 'type', 'uuid', 'isSidechain', 'parentUuid', 'model', 'stop_reason', 'message', 'content_full'];

            // Add common fields first
            commonFields.forEach(field => {
                if (allFields.has(field)) {
                    container.appendChild(createFieldCheckbox(field));
                }
            });

            // Add remaining fields
            Array.from(allFields).filter(f => !commonFields.includes(f)).forEach(field => {
                container.appendChild(createFieldCheckbox(field));
            });
        }

        function createFieldCheckbox(field) {
            const div = document.createElement('div');
            div.className = 'field-checkbox';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `field-${field}`;
            checkbox.checked = selectedFields.has(field);
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    selectedFields.add(field);
                } else {
                    selectedFields.delete(field);
                }
                renderEntries();
            });

            const label = document.createElement('label');
            label.htmlFor = `field-${field}`;
            label.textContent = field;

            div.appendChild(checkbox);
            div.appendChild(label);
            return div;
        }

        function updateStats() {
            const stats = document.getElementById('stats');
            const typeFilter = document.getElementById('typeFilter').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();

            let filtered = allEntries;
            if (typeFilter) {
                if (typeFilter === 'tool_result') {
                    filtered = filtered.filter(e => e.has_tool_results);
                } else {
                    filtered = filtered.filter(e => e.type === typeFilter);
                }
            }
            if (searchTerm) {
                filtered = filtered.filter(e =>
                    JSON.stringify(e).toLowerCase().includes(searchTerm)
                );
            }

            stats.textContent = `Showing ${filtered.length} of ${allEntries.length} entries`;
        }

        // Calculate session statistics
        function getSessionStats() {
            const sessions = {};

            // First pass: Find the most recent compact_boundary for each session
            const lastCompactTimestamp = {};
            allEntries.forEach(entry => {
                const sessionId = entry.sessionId || 'unknown';
                if (entry.type === 'system' && entry.subtype === 'compact_boundary') {
                    // Store the timestamp of the most recent compact for this session
                    if (!lastCompactTimestamp[sessionId] || entry.timestamp > lastCompactTimestamp[sessionId]) {
                        lastCompactTimestamp[sessionId] = entry.timestamp;
                    }
                }
            });

            allEntries.forEach(entry => {
                const sessionId = entry.sessionId || 'unknown';

                if (!sessions[sessionId]) {
                    sessions[sessionId] = {
                        id: sessionId,
                        messageCount: 0,
                        lastActive: null,
                        tokensUsed: 0,
                        timestamps: [],
                        todoEntries: [], // Track TodoWrite entries with timestamps
                        planEntries: [] // Track ExitPlanMode entries with timestamps
                    };
                }

                sessions[sessionId].messageCount++;

                if (entry.timestamp) {
                    sessions[sessionId].timestamps.push(entry.timestamp);
                }

                // Sum up token usage from actual content (tiktoken counts)
                // Only count tokens from entries AT OR AFTER the most recent compact
                if (entry.content_tokens !== undefined && entry.content_tokens !== null) {
                    const lastCompact = lastCompactTimestamp[sessionId];
                    // If no compact, or entry is at/after the last compact, count the tokens
                    if (!lastCompact || entry.timestamp >= lastCompact) {
                        sessions[sessionId].tokensUsed += entry.content_tokens;
                    }
                }

                // Extract ExitPlanMode tool uses (plans)
                if (entry.tool_items && entry.tool_items.tool_uses) {
                    entry.tool_items.tool_uses.forEach(toolUse => {
                        if (toolUse.name === 'ExitPlanMode' && toolUse.input && toolUse.input.plan) {
                            sessions[sessionId].planEntries.push({
                                timestamp: entry.timestamp,
                                plan: toolUse.input.plan
                            });
                        }
                    });
                }
            });

            // Calculate last active and process todos for each session
            Object.values(sessions).forEach(session => {
                if (session.timestamps.length > 0) {
                    session.lastActive = session.timestamps.sort().reverse()[0];
                }

                // Get todos from API data instead of JSONL
                const sessionTodos = allTodoData[session.id] || [];
                if (sessionTodos.length > 0) {
                    // Store all todo entries for navigation
                    session.todoEntries = sessionTodos.map(todoFile => ({
                        timestamp: todoFile.timestamp,
                        todos: todoFile.todos,
                        agentId: todoFile.agentId,
                        filename: todoFile.filename
                    }));

                    // Sort by timestamp (newest first)
                    session.todoEntries.sort((a, b) => b.timestamp.localeCompare(a.timestamp));

                    // Use latest for current display
                    const latestTodoEntry = session.todoEntries[0];
                    session.todos = latestTodoEntry.todos;

                    // Calculate todo stats
                    const stats = {
                        total: session.todos.length,
                        completed: session.todos.filter(t => t.status === 'completed').length,
                        inProgress: session.todos.filter(t => t.status === 'in_progress').length,
                        pending: session.todos.filter(t => t.status === 'pending').length
                    };

                    session.todoStats = stats;
                    session.hasTodos = stats.total > 0;
                } else {
                    session.todoEntries = [];
                }

                // Get latest plan (most recent timestamp)
                if (session.planEntries.length > 0) {
                    const latestPlanEntry = session.planEntries.sort((a, b) =>
                        b.timestamp.localeCompare(a.timestamp)
                    )[0];

                    session.latestPlan = latestPlanEntry.plan;
                    session.planCount = session.planEntries.length;
                    session.hasPlans = true;
                }
            });

            return Object.values(sessions).sort((a, b) => {
                // Sort by last active (most recent first)
                if (a.lastActive && b.lastActive) {
                    return b.lastActive.localeCompare(a.lastActive);
                }
                return 0;
            });
        }

        // Format large numbers
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        // Format timestamp for display
        function formatTimestamp(timestamp) {
            if (!timestamp) return '-';

            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'just now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;

                return date.toLocaleDateString();
            } catch (e) {
                return timestamp;
            }
        }

        // Render session summary cards
        function renderSessionSummary() {
            const container = document.getElementById('sessionCards');
            const sessions = getSessionStats();

            // Build map of current sessions
            const currentSessions = {};
            sessions.forEach(s => {
                currentSessions[s.id] = s;
            });

            // Check if we need full rebuild
            const sessionIds = Object.keys(currentSessions);
            const lastSessionIds = Object.keys(lastSessionStats);

            // Check if todo/plan data changed for any session (compare file modification timestamps)
            const todoOrPlanChanged = sessionIds.some(id => {
                const current = currentSessions[id];
                const last = lastSessionStats[id];
                if (!last) return true;

                // Check if todo file timestamps changed
                const currentTodoTimestamps = (current.todoEntries || []).map(t => t.timestamp).sort().join(',');
                const lastTodoTimestamps = (last.todoEntries || []).map(t => t.timestamp).sort().join(',');
                if (currentTodoTimestamps !== lastTodoTimestamps) return true;

                // Check if plan timestamps changed
                const currentPlanTimestamps = (current.planEntries || []).map(p => p.timestamp).sort().join(',');
                const lastPlanTimestamps = (last.planEntries || []).map(p => p.timestamp).sort().join(',');
                if (currentPlanTimestamps !== lastPlanTimestamps) return true;

                return false;
            });

            const needsRebuild = sessionIds.length !== lastSessionIds.length ||
                !sessionIds.every(id => lastSessionIds.includes(id)) ||
                todoOrPlanChanged;

            if (needsRebuild) {
                // Full rebuild
                container.innerHTML = '';

                sessions.forEach(session => {
                    const color = getSessionColor(session.id);

                    const card = document.createElement('div');
                    card.className = 'session-card';
                    card.dataset.sessionId = session.id;
                    if (selectedSession === session.id) {
                        card.classList.add('selected');
                    }
                    card.style.borderLeftColor = color;

                    // Calculate context percentage (assume 200K limit)
                    const contextLimit = 200000;
                    const contextPct = (session.tokensUsed / contextLimit) * 100;
                    const contextClass = contextPct < 70 ? 'low' : (contextPct < 90 ? 'medium' : 'high');

                    const todoHTML = session.hasTodos ? `
                        <div class="session-stat session-todo-summary" data-session-id="${session.id}">
                            <span class="session-stat-label">Todos:</span>
                            <span class="session-stat-value" style="color: #9d9d9d;">
                                ${session.todoStats.total} total:
                                <span style="color: #4ec9b0;">${session.todoStats.completed} done</span>,
                                ${session.todoStats.pending} pending
                            </span>
                        </div>
                    ` : '';

                    const planHTML = session.hasPlans ? `
                        <div class="session-stat session-plan-summary" data-session-id="${session.id}">
                            <span class="session-stat-label">Plans:</span>
                            <span class="session-stat-value" style="color: #9d9d9d;">
                                ${session.planCount} ${session.planCount === 1 ? 'plan' : 'plans'}
                            </span>
                        </div>
                    ` : '';

                    card.innerHTML = `
                        <div class="session-icon-actions">
                            <div class="session-icon-btn" data-action="filter" title="Toggle filter">
                                <div class="icon">🔍</div>
                                <div class="label">Filter</div>
                            </div>
                            ${session.hasPlans ? `
                            <div class="session-icon-btn" data-action="plans" title="View plans">
                                <div class="icon">📋</div>
                                <div class="label">Plans</div>
                            </div>
                            ` : ''}
                            ${session.hasTodos ? `
                            <div class="session-icon-btn" data-action="todos" title="View todos">
                                <div class="icon">☑</div>
                                <div class="label">Todos</div>
                            </div>
                            ` : ''}
                        </div>
                        <div class="session-id">
                            <span class="session-color-badge" style="background: ${color}; color: #fff;">
                                ${session.id.substring(0, 8)}
                            </span>
                        </div>
                        <div class="session-stats">
                            <div class="session-stat">
                                <span class="session-stat-label">Messages:</span>
                                <span class="session-stat-value" data-stat="messageCount">${session.messageCount}</span>
                            </div>
                            <div class="session-stat">
                                <span class="session-stat-label">Last Active:</span>
                                <span class="session-stat-value" data-stat="lastActive">${formatTimestamp(session.lastActive)}</span>
                            </div>
                            <div class="session-stat">
                                <span class="session-stat-label">Context:</span>
                                <span class="session-stat-value usage-value ${contextClass}" data-stat="tokensUsed" style="padding: 2px 6px; font-size: 10px;">
                                    ${formatNumber(session.tokensUsed)} / 200K (${contextPct.toFixed(1)}%)
                                </span>
                            </div>
                            ${planHTML}
                            ${todoHTML}
                        </div>
                    `;

                    // Add icon action handlers
                    const iconButtons = card.querySelectorAll('.session-icon-btn');
                    iconButtons.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const action = btn.dataset.action;

                            if (action === 'filter') {
                                // Toggle filter
                                if (selectedSession === session.id) {
                                    selectedSession = null;
                                } else {
                                    selectedSession = session.id;
                                }

                                // Update selected state and filter button active state on all cards
                                container.querySelectorAll('.session-card').forEach(c => {
                                    if (c.dataset.sessionId === selectedSession) {
                                        c.classList.add('selected');
                                        c.querySelector('[data-action="filter"]')?.classList.add('active');
                                    } else {
                                        c.classList.remove('selected');
                                        c.querySelector('[data-action="filter"]')?.classList.remove('active');
                                    }
                                });

                                renderEntries();
                            } else if (action === 'plans') {
                                showPlanDialog(session);
                            } else if (action === 'todos') {
                                showTodoDialog(session);
                            }
                        });
                    });

                    // Set initial active state for filter button if this session is selected
                    if (selectedSession === session.id) {
                        card.querySelector('[data-action="filter"]')?.classList.add('active');
                    }

                    container.appendChild(card);
                });

                lastSessionStats = currentSessions;
            } else {
                // Incremental update - only update changed stats
                sessions.forEach(session => {
                    const lastStats = lastSessionStats[session.id];

                    if (lastStats) {
                        const card = container.querySelector(`[data-session-id="${session.id}"]`);

                        if (card) {
                            // Update only changed values
                            if (session.messageCount !== lastStats.messageCount) {
                                const elem = card.querySelector('[data-stat="messageCount"]');
                                if (elem) elem.textContent = session.messageCount;
                            }

                            if (session.lastActive !== lastStats.lastActive) {
                                const elem = card.querySelector('[data-stat="lastActive"]');
                                if (elem) elem.textContent = formatTimestamp(session.lastActive);
                            }

                            if (session.tokensUsed !== lastStats.tokensUsed) {
                                const elem = card.querySelector('[data-stat="tokensUsed"]');
                                if (elem) {
                                    const contextLimit = 200000;
                                    const contextPct = (session.tokensUsed / contextLimit) * 100;
                                    const contextClass = contextPct < 70 ? 'low' : (contextPct < 90 ? 'medium' : 'high');

                                    // Update classes
                                    elem.className = `session-stat-value usage-value ${contextClass}`;
                                    elem.textContent = `${formatNumber(session.tokensUsed)} / 200K (${contextPct.toFixed(1)}%)`;
                                }
                            }
                        }
                    }
                });

                lastSessionStats = currentSessions;
            }
        }

        // Check if filters have changed
        function filtersChanged() {
            const typeFilter = document.getElementById('typeFilter').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const limit = parseInt(document.getElementById('limitSelect').value);

            // Check if selected fields changed
            const fieldsChanged = currentFilters.fields.size !== selectedFields.size ||
                ![...selectedFields].every(f => currentFilters.fields.has(f));

            return currentFilters.search !== searchTerm ||
                   currentFilters.type !== typeFilter ||
                   currentFilters.session !== selectedSession ||
                   currentFilters.limit !== limit ||
                   fieldsChanged;
        }

        // Update current filter state
        function updateFilterState() {
            currentFilters.search = document.getElementById('searchInput').value.toLowerCase();
            currentFilters.type = document.getElementById('typeFilter').value;
            currentFilters.session = selectedSession;
            currentFilters.limit = parseInt(document.getElementById('limitSelect').value);
            currentFilters.fields = new Set(selectedFields);
        }

        // Create a table row for an entry
        function createEntryRow(entry) {
            const row = document.createElement('tr');
            row.dataset.entryId = getEntryId(entry);

            // Special handling for usage-increment rows
            if (entry.type === 'usage-increment' && entry._isSnapshot) {
                row.classList.add('usage-increment-row');

                // Create a single cell that spans all columns
                const td = document.createElement('td');
                td.colSpan = selectedFields.size;
                td.className = 'usage-increment-cell';

                const snapshot = entry.snapshot;
                const fiveHourPct = snapshot.five_hour_pct ? snapshot.five_hour_pct.toFixed(1) : '0.0';
                const sevenDayPct = snapshot.seven_day_pct ? snapshot.seven_day_pct.toFixed(1) : '0.0';
                const fiveHourClass = getUsageClass(snapshot.five_hour_pct || 0);
                const sevenDayClass = getUsageClass(snapshot.seven_day_pct || 0);

                // Format tokens and messages for display with "total (+delta)" format
                const formatStat = (totalTokens, totalMessages, deltaTokens, deltaMessages) => {
                    if (totalTokens === null || totalTokens === undefined) return '—';
                    // Handle null deltas by displaying 0
                    const deltaTokensValue = (deltaTokens === null || deltaTokens === undefined) ? 0 : deltaTokens;
                    const deltaMessagesValue = (deltaMessages === null || deltaMessages === undefined) ? 0 : deltaMessages;
                    const tokensStr = `${formatNumber(totalTokens)} (+${formatNumber(deltaTokensValue)})`;
                    const messagesStr = `${totalMessages} (+${deltaMessagesValue})`;
                    return `${tokensStr} tokens | ${totalMessages === 1 ? 'message' : 'messages'}`;
                };

                const fiveHourStats = formatStat(
                    snapshot.five_hour_tokens_total,
                    snapshot.five_hour_messages_total,
                    snapshot.five_hour_tokens_consumed,
                    snapshot.five_hour_messages_count
                );
                const sevenDayStats = formatStat(
                    snapshot.seven_day_tokens_total,
                    snapshot.seven_day_messages_total,
                    snapshot.seven_day_tokens_consumed,
                    snapshot.seven_day_messages_count
                );

                td.innerHTML = `
                    <div class="usage-increment-container">
                        <div class="usage-increment-icon">📊</div>
                        <div class="usage-increment-content">
                            <div class="usage-increment-title">Usage Increment Detected</div>
                            <div class="usage-increment-details">
                                <div class="usage-increment-stat">
                                    <span class="usage-increment-label">5-Hour Window:</span>
                                    <span class="usage-increment-value usage-value ${fiveHourClass}">${fiveHourPct}% utilization</span>
                                    <span class="usage-increment-meta">${fiveHourStats}</span>
                                </div>
                                <div class="usage-increment-stat">
                                    <span class="usage-increment-label">7-Day Window:</span>
                                    <span class="usage-increment-value usage-value ${sevenDayClass}">${sevenDayPct}% utilization</span>
                                    <span class="usage-increment-meta">${sevenDayStats}</span>
                                </div>
                            </div>
                        </div>
                        <div class="usage-increment-time">${formatTimestamp(entry.timestamp)}</div>
                    </div>
                `;

                row.appendChild(td);
                return row;
            }

            Array.from(selectedFields).forEach(fieldName => {
                const td = document.createElement('td');

                // Store the raw value for copying
                let copyValue = '';

                // Handle virtual fields and actual properties
                const hasField = fieldName === 'when' || fieldName === 'tokens' || fieldName === 'content' || entry.hasOwnProperty(fieldName);
                if (hasField) {
                    // For content field, prefer content_display if available
                    let fieldValue;
                    if (fieldName === 'when') {
                        fieldValue = null;
                    } else if (fieldName === 'tokens') {
                        fieldValue = null; // Will be computed during rendering
                    } else if (fieldName === 'content' && entry.hasOwnProperty('content_display')) {
                        fieldValue = entry['content_display'];
                    } else if (fieldName === 'content') {
                        // content field but no content_display, try regular content
                        fieldValue = entry['content'] || null;
                    } else {
                        fieldValue = entry[fieldName];
                    }

                    // Set copy value based on field type
                    if (typeof fieldValue === 'object' && fieldValue !== null) {
                        copyValue = JSON.stringify(fieldValue, null, 2);
                    } else {
                        copyValue = String(fieldValue || '');
                    }

                    if (fieldName === 'type') {
                        const span = document.createElement('span');
                        span.className = `cell-type type-${fieldValue || 'other'}`;
                        span.textContent = fieldValue || 'unknown';
                        td.appendChild(span);
                    } else if (fieldName === 'role') {
                        const span = document.createElement('span');
                        span.className = `cell-type role-${fieldValue || 'other'}`;
                        span.textContent = fieldValue || '-';
                        td.appendChild(span);
                    } else if (fieldName === 'sessionId') {
                        const color = getSessionColor(fieldValue);
                        const span = document.createElement('span');
                        span.className = 'session-color-badge';
                        span.style.background = color;
                        span.style.color = '#fff';
                        span.textContent = fieldValue ? fieldValue.substring(0, 8) : '-';
                        td.appendChild(span);
                    } else if (fieldName === 'timestamp') {
                        td.className = 'cell-timestamp';
                        td.textContent = fieldValue || '-';
                    } else if (fieldName === 'when') {
                        // Special handling for 'when' field - compute from timestamp
                        const relativeTime = formatRelativeTime(entry.timestamp);
                        td.className = 'cell-when';
                        td.textContent = relativeTime;
                        copyValue = relativeTime; // Update copy value
                    } else if (fieldName === 'tokens') {
                        // Special handling for 'tokens' virtual field - combine input and output
                        td.className = 'cell-tokens';
                        td.style.textAlign = 'right';
                        const inTokens = entry.input_tokens;
                        const outTokens = entry.output_tokens;
                        if ((inTokens !== undefined && inTokens !== 0) || (outTokens !== undefined && outTokens !== 0)) {
                            const inStr = inTokens ? inTokens.toLocaleString() : '0';
                            const outStr = outTokens ? outTokens.toLocaleString() : '0';
                            td.textContent = `↑${inStr} ↓${outStr}`;
                            copyValue = `in: ${inStr}, out: ${outStr}`;
                        } else {
                            td.textContent = '-';
                        }
                    } else if (fieldName === 'content_tokens') {
                        // Special handling for content token counts (from tiktoken)
                        td.className = 'cell-tokens';
                        td.style.textAlign = 'right';
                        if (fieldValue !== undefined && fieldValue !== null && fieldValue !== 0) {
                            // Format as ~2.5k or ~156
                            let formatted;
                            if (fieldValue >= 1000) {
                                const kValue = fieldValue / 1000;
                                if (kValue >= 100) {
                                    formatted = `~${Math.round(kValue)}k`;
                                } else {
                                    formatted = `~${kValue.toFixed(1)}k`;
                                }
                            } else {
                                formatted = `~${fieldValue}`;
                            }
                            td.textContent = formatted;
                            copyValue = `${fieldValue} tokens`;
                        } else {
                            td.textContent = '-';
                        }
                    } else if (fieldName === 'input_tokens' || fieldName === 'output_tokens') {
                        // Special handling for API token fields
                        td.className = 'cell-tokens';
                        td.style.textAlign = 'right';
                        if (fieldValue !== undefined && fieldValue !== null && fieldValue !== 0) {
                            // Format number with commas
                            td.textContent = fieldValue.toLocaleString();
                        } else {
                            td.textContent = '-';
                        }
                    } else if (typeof fieldValue === 'object' && fieldValue !== null) {
                        const pre = document.createElement('div');
                        pre.className = 'cell-json';
                        pre.textContent = JSON.stringify(fieldValue, null, 2);
                        td.appendChild(pre);
                    } else {
                        const div = document.createElement('div');
                        div.className = 'cell-text';

                        const originalText = String(fieldValue || '-');
                        const truncatedText = truncateContent(originalText);

                        // Check if content has tool indicators and entry has tool_items data
                        const hasToolIndicators = originalText.includes('🔧') || originalText.includes('✓');
                        const hasToolItems = entry.tool_items &&
                            (entry.tool_items.tool_uses?.length > 0 || entry.tool_items.tool_results?.length > 0);

                        if (truncatedText !== originalText) {
                            // Text was truncated, make it clickable to open in modal
                            div.classList.add('truncated');
                            div.textContent = truncatedText;

                            const indicator = document.createElement('span');
                            indicator.className = 'expand-indicator';
                            indicator.textContent = '▼ click to view';
                            div.appendChild(indicator);

                            // Open modal dialog on click
                            div.addEventListener('click', (e) => {
                                e.stopPropagation(); // Prevent copy-to-clipboard handler
                                showContentDialog(originalText);
                            });
                        } else if (hasToolIndicators && hasToolItems) {
                            // Content has tool uses/results, make it clickable to show JSON
                            div.classList.add('has-tools');
                            div.textContent = originalText;

                            const indicator = document.createElement('span');
                            indicator.className = 'expand-indicator';
                            indicator.textContent = '▼ view details';
                            div.appendChild(indicator);

                            // Open modal with tool JSON on click
                            div.addEventListener('click', (e) => {
                                e.stopPropagation(); // Prevent copy-to-clipboard handler
                                showToolDetailsDialog(entry);
                            });
                        } else {
                            div.textContent = originalText;
                        }

                        td.appendChild(div);
                    }
                } else {
                    td.textContent = '-';
                    copyValue = '';
                }

                // Add click to copy handler
                if (copyValue) {
                    td.addEventListener('click', (e) => {
                        // Don't interfere with modal dialog clicks or expand indicator
                        if (!e.target.classList.contains('expand-indicator') &&
                            !e.target.classList.contains('truncated')) {
                            copyToClipboard(copyValue);
                        }
                    });
                }

                row.appendChild(td);
            });

            return row;
        }

        function renderEntries() {
            const container = document.getElementById('entriesContainer');
            const typeFilter = document.getElementById('typeFilter').value;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const limit = parseInt(document.getElementById('limitSelect').value);

            let filtered = allEntries;

            if (typeFilter) {
                if (typeFilter === 'tool_result') {
                    // Filter for entries that have tool results
                    filtered = filtered.filter(e => e.has_tool_results);
                } else {
                    filtered = filtered.filter(e => e.type === typeFilter);
                }
            }

            if (searchTerm) {
                filtered = filtered.filter(e =>
                    JSON.stringify(e).toLowerCase().includes(searchTerm)
                );
            }

            // Filter by selected session
            if (selectedSession) {
                filtered = filtered.filter(e => e.sessionId === selectedSession);
            }

            filtered = filtered.slice(0, limit);

            if (filtered.length === 0) {
                container.innerHTML = '<div class="empty-state"><h2>No entries found</h2><p>Try adjusting your filters</p></div>';
                renderedEntryIds.clear();
                updateFilterState();
                return;
            }

            // Check if we need a full rebuild or can append
            const needsRebuild = filtersChanged();

            if (needsRebuild) {
                // Full rebuild needed
                renderedEntryIds.clear();

                // Create table
                const table = document.createElement('table');

                // Create header
                const thead = document.createElement('thead');
                const headerRow = document.createElement('tr');

                Array.from(selectedFields).forEach(fieldName => {
                    const th = document.createElement('th');
                    th.textContent = fieldName;
                    headerRow.appendChild(th);
                });

                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Create body
                const tbody = document.createElement('tbody');

                filtered.forEach(entry => {
                    const row = createEntryRow(entry);
                    tbody.appendChild(row);
                    renderedEntryIds.add(getEntryId(entry));
                });

                table.appendChild(tbody);

                container.innerHTML = '';
                const tableContainer = document.createElement('div');
                tableContainer.className = 'table-container';
                tableContainer.appendChild(table);
                container.appendChild(tableContainer);

                updateFilterState();
            } else {
                // Incremental update - only add new entries
                const existingTable = container.querySelector('table');

                if (!existingTable) {
                    // Table doesn't exist, do full rebuild
                    renderedEntryIds.clear();

                    const table = document.createElement('table');
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');

                    Array.from(selectedFields).forEach(fieldName => {
                        const th = document.createElement('th');
                        th.textContent = fieldName;
                        headerRow.appendChild(th);
                    });

                    thead.appendChild(headerRow);
                    table.appendChild(thead);

                    const tbody = document.createElement('tbody');

                    filtered.forEach(entry => {
                        const row = createEntryRow(entry);
                        tbody.appendChild(row);
                        renderedEntryIds.add(getEntryId(entry));
                    });

                    table.appendChild(tbody);

                    container.innerHTML = '';
                    const tableContainer = document.createElement('div');
                    tableContainer.className = 'table-container';
                    tableContainer.appendChild(table);
                    container.appendChild(tableContainer);
                } else {
                    // Append only new entries
                    const tbody = existingTable.querySelector('tbody');

                    filtered.forEach(entry => {
                        const entryId = getEntryId(entry);
                        if (!renderedEntryIds.has(entryId)) {
                            const row = createEntryRow(entry);
                            // Insert at the beginning (newest first)
                            tbody.insertBefore(row, tbody.firstChild);
                            renderedEntryIds.add(entryId);
                        }
                    });
                }
            }

            updateStats();
        }

        function toggleAutoRefresh() {
            const checkbox = document.getElementById('autoRefreshCheck');
            const container = document.getElementById('autoRefresh');
            const intervalSelect = document.getElementById('refreshInterval');

            if (checkbox.checked) {
                container.classList.add('active');
                const intervalMs = parseInt(intervalSelect.value) * 1000;
                autoRefreshInterval = setInterval(loadEntries, intervalMs);
            } else {
                container.classList.remove('active');
                if (autoRefreshInterval) {
                    clearInterval(autoRefreshInterval);
                    autoRefreshInterval = null;
                }
            }
        }

        function updateAutoRefreshInterval() {
            const checkbox = document.getElementById('autoRefreshCheck');
            if (checkbox.checked) {
                // Restart with new interval
                toggleAutoRefresh(); // Stop
                checkbox.checked = false;
                setTimeout(() => {
                    checkbox.checked = true;
                    toggleAutoRefresh(); // Start with new interval
                }, 0);
            }
        }

        // Event listeners
        document.getElementById('refreshBtn').addEventListener('click', loadEntries);
        document.getElementById('searchInput').addEventListener('input', renderEntries);
        document.getElementById('typeFilter').addEventListener('change', renderEntries);
        document.getElementById('limitSelect').addEventListener('change', renderEntries);
        document.getElementById('autoRefreshCheck').addEventListener('change', toggleAutoRefresh);
        document.getElementById('refreshInterval').addEventListener('change', updateAutoRefreshInterval);

        // Initial load
        loadEntries();
        startUsagePolling();

        // Enable auto-refresh by default
        document.getElementById('autoRefreshCheck').checked = true;
        toggleAutoRefresh();
    </script>

    <!-- Modal Dialog -->
    <div class="modal-overlay" id="contentModal">
        <div class="modal-dialog">
            <div class="modal-header">
                <div class="modal-title">Content Viewer</div>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-content" id="modalContent"></div>
            </div>
        </div>
    </div>
</body>
</html>
